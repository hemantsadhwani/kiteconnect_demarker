#!/usr/bin/env python3
"""
Renko Chart Plotter with Supertrend Indicator
Plots Renko bricks from nifty50_1min_data_renko.csv (generated by stocktrends) with Supertrend overlay
"""

import pandas as pd
import numpy as np
import json
import yaml
import os
import sys
import logging
from datetime import datetime
from zoneinfo import ZoneInfo
from pathlib import Path

# Add parent directory to path for indicators import
parent_dir = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(parent_dir))

from indicators_backtesting import calculate_supertrend

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def convert_datetime_to_unix(date_str):
    """Convert various date formats to a Unix timestamp."""
    date_str = str(date_str).strip()
    
    if '+05:30' in date_str:
        date_str = date_str.replace('+05:30', '').strip()
    
    formats_to_try = [
        '%Y-%m-%d %H:%M:%S',
        '%d/%m/%Y %I:%M:%S %p'
    ]
    
    dt_naive = None
    for fmt in formats_to_try:
        try:
            dt_naive = datetime.strptime(date_str, fmt)
            break
        except ValueError:
            continue

    if dt_naive is None:
        logger.error(f"Could not parse date '{date_str}'")
        return None

    try:
        ist = ZoneInfo("Asia/Kolkata")
        dt_aware = dt_naive.replace(tzinfo=ist)
        return int(dt_aware.timestamp())
    except Exception as e:
        logger.error(f"Error converting timestamp for '{date_str}': {e}")
        return None

def process_renko_csv_data(csv_file_path, config_path=None):
    """Process the Renko CSV file and prepare data for JavaScript"""
    
    logger.info(f"Processing Renko CSV file: {csv_file_path}")
    
    # Load configuration
    if config_path is None:
        config_path = Path(__file__).parent / 'renko_config.yaml'
    
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        renko_config = config.get('RENKO', {})
        supertrend_config = config.get('SUPERTREND', {})
        brick_size = renko_config.get('BRICK_SIZE', 5)
        st_period = supertrend_config.get('PERIOD', 10)
        st_multiplier = supertrend_config.get('MULTIPLIER', 2.0)
        logger.info(f"Loaded config: brick_size={brick_size}, ST({st_period}, {st_multiplier})")
    except Exception as e:
        logger.warning(f"Could not load config, using defaults: {e}")
        brick_size = 5
        st_period = 10
        st_multiplier = 2.0
    
    # Read the Renko CSV data
    df = pd.read_csv(csv_file_path, header=0)
    logger.info(f"Loaded CSV with {len(df)} Renko bricks")
    
    # Convert date column
    df['date'] = pd.to_datetime(df['date'])
    
    # Check if Supertrend columns already exist in CSV (calculated with warmup)
    if 'supertrend' in df.columns and 'supertrend_dir' in df.columns:
        logger.info("Using Supertrend values from CSV file (calculated with warmup data)")
        # Ensure supertrend columns are numeric
        df['supertrend'] = pd.to_numeric(df['supertrend'], errors='coerce')
        df['supertrend_dir'] = pd.to_numeric(df['supertrend_dir'], errors='coerce')
    else:
        # Calculate Supertrend on Renko bricks (if not already in CSV)
        logger.info("Calculating Supertrend indicator on Renko bricks (CSV doesn't have supertrend columns)...")
        df = calculate_supertrend(df, atr_period=st_period, factor=st_multiplier)
    
    # Find the first 9:15 AM timestamp to start plotting from there
    start_index = None
    for index, row in df.iterrows():
        date_str = str(row['date'])
        if '09:15:00' in date_str or '09:15' in date_str:
            start_index = index
            break
    
    if start_index is None:
        logger.warning("Could not find 9:15 AM timestamp, using all data")
        start_index = 0
    else:
        logger.info(f"Found 9:15 AM at index {start_index}, starting from there")
    
    # Use data from start_index onwards
    df = df.iloc[start_index:].reset_index(drop=True)
    
    # Process Renko brick data (use as candlesticks)
    # IMPORTANT: LightweightCharts requires unique timestamps for proper visualization
    # So we use sequential timestamps for display, but store actual timestamp for tooltip
    logger.info(f"Using sequential timestamps for visualization (with actual timestamps for tooltips)")
    
    # Get base time from first brick for sequential assignment
    first_date = df.iloc[0]['date']
    base_time = convert_datetime_to_unix(str(first_date))
    if base_time is None:
        logger.error("Could not convert first date to timestamp")
        raise ValueError("Invalid first date timestamp")
    
    renko_data = []
    supertrend_data = []
    brick_index = 0  # Track brick index for sequential timestamps
    
    for _, row in df.iterrows():
        # Get actual timestamp from CSV (for tooltip display)
        date_str = str(row['date'])
        actual_time = convert_datetime_to_unix(date_str)
        
        if actual_time is None or actual_time <= 0:
            logger.warning(f"Invalid timestamp for brick: {date_str}, skipping")
            continue
        
        # Use sequential timestamp for chart display (ensures unique timestamps)
        # Each brick gets base_time + (brick_index * 60 seconds) for proper visualization
        display_time = base_time + (brick_index * 60)
        
        # Validate OHLC values
        try:
            open_val = float(row['open'])
            high_val = float(row['high'])
            low_val = float(row['low'])
            close_val = float(row['close'])
            
            # Check for NaN or invalid values
            if pd.isna(open_val) or pd.isna(high_val) or pd.isna(low_val) or pd.isna(close_val):
                continue
            
            # Validate OHLC logic: high >= max(open,close) and low <= min(open,close)
            if high_val < max(open_val, close_val) or low_val > min(open_val, close_val):
                # Fix invalid OHLC
                high_val = max(open_val, close_val, high_val)
                low_val = min(open_val, close_val, low_val)
            
            # Renko brick data (as candlestick)
            # Store both display_time (for chart) and actual_time (for tooltip)
            renko_data.append({
                'time': display_time,  # Sequential time for chart visualization
                'actual_time': actual_time,  # Actual timestamp from CSV for tooltip
                'open': open_val,
                'high': high_val,
                'low': low_val,
                'close': close_val
            })
            
            # Increment brick index for next sequential timestamp
            brick_index += 1
        except (ValueError, TypeError) as e:
            logger.warning(f"Skipping row with invalid OHLC values: {e}")
            continue
        
        # Supertrend data (only if not NaN) - use display_time to match Renko brick visualization
        try:
            st_value = row.get('supertrend', np.nan)
            st_dir = row.get('supertrend_dir', np.nan)
            
            if pd.notna(st_value) and pd.notna(st_dir):
                st_value = float(st_value)
                st_dir = int(float(st_dir))
                
                if pd.notna(st_value) and not np.isinf(st_value):
                    # Use display_time to align with Renko brick visualization
                    # The actual_time is stored in the Renko brick data for tooltip lookup
                    supertrend_data.append({
                        'time': display_time,  # Same display_time as the Renko brick
                        'value': st_value,
                        'direction': st_dir
                    })
        except (ValueError, TypeError) as e:
            # Skip invalid supertrend data
            pass
    
    # Validate we have data
    if len(renko_data) == 0:
        logger.error("No valid Renko brick data found after processing!")
        raise ValueError("No valid Renko bricks to plot")
    
    # Sort by time to ensure chronological order
    renko_data.sort(key=lambda x: x['time'])
    supertrend_data.sort(key=lambda x: x['time'])
    
    # Final validation: Remove any remaining invalid entries and ensure all values are numbers (not None)
    def is_valid_number(val):
        """Check if value is a valid number (not None, not NaN, not Infinity)"""
        if val is None:
            return False
        try:
            float_val = float(val)
            return not (np.isnan(float_val) or np.isinf(float_val))
        except (ValueError, TypeError):
            return False
    
    renko_data_clean = []
    for brick in renko_data:
        if (is_valid_number(brick['time']) and 
            is_valid_number(brick['open']) and 
            is_valid_number(brick['high']) and 
            is_valid_number(brick['low']) and 
            is_valid_number(brick['close'])):
            # Ensure all values are Python floats (not numpy types)
            renko_data_clean.append({
                'time': int(float(brick['time'])),
                'open': float(brick['open']),
                'high': float(brick['high']),
                'low': float(brick['low']),
                'close': float(brick['close'])
            })
    
    renko_data = renko_data_clean
    
    supertrend_data_clean = []
    for st in supertrend_data:
        if (is_valid_number(st['time']) and
            is_valid_number(st['value']) and
            is_valid_number(st['direction'])):
            supertrend_data_clean.append({
                'time': int(float(st['time'])),
                'value': float(st['value']),
                'direction': int(float(st['direction']))
            })
    supertrend_data = supertrend_data_clean
    
    if len(renko_data) == 0:
        logger.error("No valid Renko brick data after final validation!")
        raise ValueError("No valid Renko bricks to plot")
    
    # Create time mapping dictionary: display_time -> actual_time
    # This ensures the mapping is preserved even if actual_time field gets lost in JSON
    time_mapping = {}
    for brick in renko_data:
        display_time = brick['time']
        # Ensure actual_time exists - it should have been set when creating the brick
        if 'actual_time' not in brick:
            logger.error(f"Brick missing actual_time field! Keys: {list(brick.keys())}")
        actual_time = brick.get('actual_time')
        if actual_time is None:
            logger.warning(f"Brick at display_time {display_time} has None actual_time, using display_time as fallback")
            actual_time = display_time
        time_mapping[int(display_time)] = int(actual_time)
    
    logger.info(f"Processed {len(renko_data)} Renko bricks and {len(supertrend_data)} Supertrend points")
    logger.info(f"Created time mapping with {len(time_mapping)} entries")
    if renko_data:
        logger.info(f"Time range: {renko_data[0]['time']} to {renko_data[-1]['time']}")
        # Debug: Check first few bricks to verify actual_time is included and different from display_time
        if len(renko_data) > 0:
            first_brick = renko_data[0]
            logger.info(f"Sample brick keys: {list(first_brick.keys())}")
            first_display = first_brick.get('time')
            first_actual = first_brick.get('actual_time')
            logger.info(f"First brick: display_time={first_display}, actual_time={first_actual}, same={first_display == first_actual}")
            if len(renko_data) > 10:
                tenth_display = renko_data[9].get('time')
                tenth_actual = renko_data[9].get('actual_time')
                logger.info(f"10th brick: display_time={tenth_display}, actual_time={tenth_actual}, same={tenth_display == tenth_actual}")
                # Show some sample mappings
                sample_mappings = list(time_mapping.items())[:5]
                logger.info(f"Sample time_mapping entries: {sample_mappings}")
    
    return {
        'renko': renko_data,
        'supertrend': supertrend_data,
        'time_mapping': time_mapping,  # Explicit mapping dictionary
        'brick_size': brick_size,
        'st_period': st_period,
        'st_multiplier': st_multiplier
    }

def generate_html(csv_file_path, output_file=None, config_path=None):
    """Generate the complete HTML file for Renko chart"""
    
    # Process the data
    data = process_renko_csv_data(csv_file_path, config_path)
    
    if output_file is None:
        output_file = Path(__file__).parent / 'nifty_renko_plot.html'
    
    html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Renko Chart with Supertrend - NIFTY 50</title>
    <script>
        // CRITICAL: Set up error suppression BEFORE loading the library
        // This must run first to catch errors during library initialization
        (function() {{
            let suppressedCount = 0;
            window.onerror = function(msg, src, line, col, err) {{
                if (String(msg).includes('Value is null')) {{
                    suppressedCount++;
                    if (suppressedCount === 1 || suppressedCount % 100 === 0) {{
                        console.warn(`[Suppressed ${{suppressedCount}} internal library errors - chart is functional]`);
                    }}
                    return true; // Suppress error
                }}
                return false; // Let other errors through
            }};
        }})();
    </script>
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #131722;
            color: #D9D9D9;
            margin: 0;
            padding: 20px;
        }}
        
        #chart-container {{
            width: 100%;
            min-width: 800px;
            height: 800px;
            position: relative;
            background-color: #131722;
        }}
        
        #main-chart {{
            width: 100%;
            height: 100%;
        }}
        
        #legend {{
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
        }}
        
        .legend-item {{
            margin: 4px 0;
        }}
        
        .legend-color {{
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 8px;
            vertical-align: middle;
            border-radius: 2px;
        }}
    </style>
</head>
<body>
    <div id="chart-container">
        <div id="legend">
            <div class="legend-item">
                <span class="legend-color" style="background-color: #26A69A;"></span>
                <span>Bullish Renko Brick</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #EF5350;"></span>
                <span>Bearish Renko Brick</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #26A69A; border: 2px solid #26A69A;"></span>
                <span>Supertrend Bullish (ST={data['st_period']}, {data['st_multiplier']})</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #EF5350; border: 2px solid #EF5350;"></span>
                <span>Supertrend Bearish</span>
            </div>
            <div class="legend-item" style="margin-top: 8px;">
                <span>Brick Size: {data['brick_size']} points</span>
            </div>
        </div>
        <div id="main-chart"></div>
    </div>
    
    <div id="market-data" style="position: fixed; right: 20px; top: 20px; padding: 12px; background-color: #1E222D; border-radius: 6px; z-index: 2000; min-width: 200px;">
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <div><strong>Time:</strong> <span id="md-time">-</span></div>
            <div><strong>Open:</strong> <span id="md-open">-</span></div>
            <div><strong>High:</strong> <span id="md-high">-</span></div>
            <div><strong>Low:</strong> <span id="md-low">-</span></div>
            <div><strong>Close:</strong> <span id="md-close">-</span></div>
            <div><strong>Supertrend:</strong> <span id="md-st">-</span></div>
            <div><strong>ST Direction:</strong> <span id="md-st-dir">-</span></div>
        </div>
    </div>

    <script>
        // Global error suppression for LightweightCharts internal errors
        // These errors don't break functionality but clutter the console
        let suppressedErrorCount = 0;
        const originalConsoleError = console.error;
        
        // Override console.error to filter out LightweightCharts internal errors
        console.error = function(...args) {{
            const errorString = args.join(' ');
            if (errorString.includes('Value is null') && 
                (errorString.includes('lightweight-charts') || args.some(arg => 
                    arg && typeof arg === 'object' && arg.stack && arg.stack.includes('lightweight-charts')))) {{
                suppressedErrorCount++;
                // Only log summary every 50 errors
                if (suppressedErrorCount === 1 || suppressedErrorCount % 50 === 0) {{
                    originalConsoleError.call(console, `[Suppressed ${{suppressedErrorCount}} LightweightCharts internal rendering errors - chart functional]`);
                }}
                return; // Don't log the actual error
            }}
            // For all other errors, call the original console.error
            originalConsoleError.apply(console, args);
        }};
        
        // Also handle window error events
        window.addEventListener('error', function(event) {{
            if (event.message && typeof event.message === 'string' && 
                event.message.includes('Value is null') &&
                event.filename && event.filename.includes('lightweight-charts')) {{
                suppressedErrorCount++;
                event.preventDefault();
                event.stopPropagation();
                if (suppressedErrorCount === 1 || suppressedErrorCount % 50 === 0) {{
                    console.warn(`[Suppressed ${{suppressedErrorCount}} LightweightCharts rendering errors]`);
                }}
                return true;
            }}
        }}, true);
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {{
            const reason = event.reason;
            if (reason && typeof reason === 'object' && 
                reason.message && reason.message.includes('Value is null')) {{
                suppressedErrorCount++;
                event.preventDefault();
                if (suppressedErrorCount === 1 || suppressedErrorCount % 50 === 0) {{
                    console.warn(`[Suppressed ${{suppressedErrorCount}} LightweightCharts promise rejections]`);
                }}
            }}
        }}, true);
        
        document.addEventListener('DOMContentLoaded', function() {{
            // Parse JSON data - data is already validated in Python
            const rawData = {json.dumps(data, indent=8, ensure_ascii=False).replace('    ', '        ')};
            
            // Additional JavaScript-side cleanup with strict validation
        // Create lookup map: display_time -> actual_time for tooltip display
        // Use explicit time_mapping from Python if available, otherwise fallback to extracting from bricks
        const timeLookupMap = new Map();
        const rawRenkoWithActualTime = [];
        
        // First try to use explicit time_mapping from Python
        if (rawData.time_mapping && typeof rawData.time_mapping === 'object') {{
            console.log(`Using explicit time_mapping from Python ({{Object.keys(rawData.time_mapping).length}} entries)`);
            for (const [displayTimeStr, actualTimeStr] of Object.entries(rawData.time_mapping)) {{
                const displayTime = Number(displayTimeStr);
                const actualTime = Number(actualTimeStr);
                if (!isNaN(displayTime) && !isNaN(actualTime) && displayTime > 0 && actualTime > 0) {{
                    timeLookupMap.set(displayTime, actualTime);
                    rawRenkoWithActualTime.push({{
                        displayTime: displayTime,
                        actualTime: actualTime
                    }});
                }}
            }}
        }} else {{
            // Fallback: try to extract from brick objects
            console.log(`time_mapping not found, extracting from brick objects`);
            (rawData.renko || []).forEach(brick => {{
                const displayTime = Number(brick.time);
                const actualTime = Number(brick.actual_time || brick.time); // Fallback to time if actual_time missing
                if (!isNaN(displayTime) && !isNaN(actualTime) && displayTime > 0 && actualTime > 0) {{
                    timeLookupMap.set(displayTime, actualTime);
                    rawRenkoWithActualTime.push({{
                        displayTime: displayTime,
                        actualTime: actualTime
                    }});
                }}
            }});
        }}
        
        console.log(`Created time lookup map with ${{timeLookupMap.size}} entries`);
        if (timeLookupMap.size > 0) {{
            const firstEntry = Array.from(timeLookupMap.entries())[0];
            const secondEntry = timeLookupMap.size > 1 ? Array.from(timeLookupMap.entries())[1] : null;
            const firstDate = new Date(firstEntry[0] * 1000);
            const firstActualDate = new Date(firstEntry[1] * 1000);
            console.log(`First lookup entry: displayTime=${{firstEntry[0]}} ({{firstDate.toLocaleString('en-IN', {{timeZone: 'Asia/Kolkata'}})}}), actualTime=${{firstEntry[1]}} ({{firstActualDate.toLocaleString('en-IN', {{timeZone: 'Asia/Kolkata'}})}})`);
            if (secondEntry) {{
                const secondDate = new Date(secondEntry[0] * 1000);
                const secondActualDate = new Date(secondEntry[1] * 1000);
                console.log(`Second lookup entry: displayTime=${{secondEntry[0]}} ({{secondDate.toLocaleString('en-IN', {{timeZone: 'Asia/Kolkata'}})}}), actualTime=${{secondEntry[1]}} ({{secondActualDate.toLocaleString('en-IN', {{timeZone: 'Asia/Kolkata'}})}})`);
            }}
        }}
        
        const data = {{
            renko: (rawData.renko || []).map(brick => ({{
                time: Number(brick.time),
                open: Number(brick.open),
                high: Number(brick.high),
                low: Number(brick.low),
                close: Number(brick.close)
            }})).filter(brick => {{
                return !isNaN(brick.time) && brick.time > 0 &&
                       !isNaN(brick.open) && isFinite(brick.open) &&
                       !isNaN(brick.high) && isFinite(brick.high) &&
                       !isNaN(brick.low) && isFinite(brick.low) &&
                       !isNaN(brick.close) && isFinite(brick.close);
            }}),
            supertrend: (rawData.supertrend || []).map(point => ({{
                time: Number(point.time),
                value: Number(point.value),
                direction: Number(point.direction)
            }})).filter(point => {{
                return !isNaN(point.time) && point.time > 0 &&
                       !isNaN(point.value) && isFinite(point.value) &&
                       !isNaN(point.direction) && isFinite(point.direction);
            }}),
            brick_size: Number(rawData.brick_size) || 5,
            st_period: Number(rawData.st_period) || 10,
            st_multiplier: Number(rawData.st_multiplier) || 2.0
        }};
        
        console.log(`Loaded ${{data.renko.length}} Renko bricks and ${{data.supertrend.length}} Supertrend points`);
        
        if (data.renko.length === 0) {{
            console.error('No valid Renko data after filtering!');
            document.getElementById('chart-container').innerHTML = '<div style="color: #EF5350; padding: 20px;">Error: No valid Renko data found after filtering</div>';
            return;
        }}

        const chartOptions = {{
            layout: {{
                background: {{ type: 'solid', color: '#131722' }},
                textColor: '#D9D9D9',
            }},
            grid: {{
                vertLines: {{ color: '#2A2E39' }},
                horzLines: {{ color: '#2A2E39' }},
            }},
            crosshair: {{
                mode: LightweightCharts.CrosshairMode.Normal,
            }},
            rightPriceScale: {{
                borderColor: '#485158',
                drawTicks: false,
            }},
            timeScale: {{
                borderColor: '#485158',
                timeVisible: true,
                secondsVisible: false,
                tickMarkFormatter: (time, tickMarkType, locale) => {{
                    const date = new Date(time * 1000);
                    return date.toLocaleTimeString('en-IN', {{ hour: '2-digit', minute: '2-digit', timeZone: 'Asia/Kolkata' }});
                }},
            }},
        }};

        const chartContainer = document.getElementById('main-chart');
        const containerWidth = chartContainer.clientWidth || window.innerWidth - 40;
        const containerHeight = 800;
        
        console.log(`Creating chart with dimensions: ${{containerWidth}}x${{containerHeight}}`);
        
        const chart = LightweightCharts.createChart(chartContainer, {{
            ...chartOptions,
            width: containerWidth,
            height: containerHeight,
            autoSize: true,
        }});
        
        // Handle window resize
        window.addEventListener('resize', () => {{
            const newWidth = chartContainer.clientWidth || window.innerWidth - 40;
            chart.applyOptions({{ width: newWidth }});
        }});

        // Data is already filtered in Python, but ensure no null values reach the chart
        // LightweightCharts is very strict - it will throw if any value is null
        const validRenkoData = [];
        for (let i = 0; i < data.renko.length; i++) {{
            const brick = data.renko[i];
            
            // Skip null/undefined entries
            if (!brick || brick === null || brick === undefined) {{
                console.warn(`Skipping null brick at index ${{i}}`);
                continue;
            }}
            
            // Extract and validate each value individually
            let time = null;
            if (typeof brick.time === 'number') {{
                time = brick.time;
            }} else if (brick.time != null) {{
                time = Number(brick.time);
            }}
            
            let open = null;
            if (typeof brick.open === 'number') {{
                open = brick.open;
            }} else if (brick.open != null) {{
                open = Number(brick.open);
            }}
            
            let high = null;
            if (typeof brick.high === 'number') {{
                high = brick.high;
            }} else if (brick.high != null) {{
                high = Number(brick.high);
            }}
            
            let low = null;
            if (typeof brick.low === 'number') {{
                low = brick.low;
            }} else if (brick.low != null) {{
                low = Number(brick.low);
            }}
            
            let close = null;
            if (typeof brick.close === 'number') {{
                close = brick.close;
            }} else if (brick.close != null) {{
                close = Number(brick.close);
            }}
            
            // Only add if ALL values are valid finite numbers
            if (time != null && open != null && high != null && low != null && close != null &&
                typeof time === 'number' && typeof open === 'number' && 
                typeof high === 'number' && typeof low === 'number' && typeof close === 'number' &&
                isFinite(time) && isFinite(open) && isFinite(high) && isFinite(low) && isFinite(close) &&
                time > 0 && !isNaN(time) && !isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close)) {{
                // Create fresh object to avoid any reference issues
                validRenkoData.push({{
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close
                }});
            }} else {{
                console.warn(`Skipping invalid brick at index ${{i}}:`, brick);
            }}
        }}
        
        if (validRenkoData.length === 0) {{
            console.error('No valid Renko data to display after filtering');
            document.getElementById('chart-container').innerHTML = '<div style="color: #EF5350; padding: 20px;">Error: No valid Renko data found</div>';
            return;
        }}
        
        console.log(`Plotting ${{validRenkoData.length}} Renko bricks (first brick:`, validRenkoData[0], ')');
        
        // Add Renko bricks as candlesticks with visible colors
        const renkoSeries = chart.addCandlestickSeries({{
            upColor: '#26A69A',      // Green for bullish
            downColor: '#EF5350',    // Red for bearish
            borderDownColor: '#EF5350',
            borderUpColor: '#26A69A',
            wickDownColor: '#EF5350',
            wickUpColor: '#26A69A',
            priceLineVisible: true,
            lastValueVisible: true,
            priceLineWidth: 2,
            title: 'Renko Bricks',
            visible: true
        }});
        
        console.log('Renko candlestick series created');
        
        // Set data immediately - simpler approach like reference implementations
        // First, prepare clean data array with EXTREMELY strict validation
        const cleanRenkoData = [];
        for (let idx = 0; idx < validRenkoData.length; idx++) {{
            const brick = validRenkoData[idx];
            
            // Skip null/undefined entries
            if (!brick || brick === null || brick === undefined || typeof brick !== 'object') {{
                continue;
            }}
            
            // Extract and validate each property individually - use strict checks
            let time, open, high, low, close;
            
            // Validate time
            if (typeof brick.time === 'number' && isFinite(brick.time) && !isNaN(brick.time) && brick.time > 0) {{
                time = Math.floor(Number(brick.time));
            }} else {{
                continue; // Skip this brick entirely
            }}
            
            // Validate open
            if (typeof brick.open === 'number' && isFinite(brick.open) && !isNaN(brick.open)) {{
                open = Number(brick.open);
            }} else {{
                continue;
            }}
            
            // Validate high
            if (typeof brick.high === 'number' && isFinite(brick.high) && !isNaN(brick.high)) {{
                high = Number(brick.high);
            }} else {{
                continue;
            }}
            
            // Validate low
            if (typeof brick.low === 'number' && isFinite(brick.low) && !isNaN(brick.low)) {{
                low = Number(brick.low);
            }} else {{
                continue;
            }}
            
            // Validate close
            if (typeof brick.close === 'number' && isFinite(brick.close) && !isNaN(brick.close)) {{
                close = Number(brick.close);
            }} else {{
                continue;
            }}
            
            // Final validation: ensure candlestick structure is valid
            if (high >= Math.max(open, close) && low <= Math.min(open, close) && high >= low) {{
                // Create completely new object with ONLY the 5 required properties
                // Use Object.freeze to ensure no modifications
                const cleanBrick = Object.freeze({{
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close
                }});
                cleanRenkoData.push(cleanBrick);
            }}
        }}
        
        console.log(`Prepared ${{cleanRenkoData.length}} clean Renko bricks from ${{validRenkoData.length}}`);
        
        if (cleanRenkoData.length === 0) {{
            console.error('No valid Renko data!');
            document.getElementById('chart-container').innerHTML = '<div style="color: #EF5350; padding: 20px;">Error: No valid Renko data found</div>';
            return;
        }}
        
        // Set data immediately after chart creation (like reference implementations)
        if (cleanRenkoData.length > 0) {{
            // Final verification: ensure no nulls/undefined in the array
            const finalData = cleanRenkoData.filter(b => {{
                return b && 
                       typeof b.time === 'number' && b.time > 0 &&
                       typeof b.open === 'number' && 
                       typeof b.high === 'number' &&
                       typeof b.low === 'number' &&
                       typeof b.close === 'number' &&
                       isFinite(b.time) && isFinite(b.open) && isFinite(b.high) &&
                       isFinite(b.low) && isFinite(b.close) &&
                       !isNaN(b.time) && !isNaN(b.open) && !isNaN(b.high) &&
                       !isNaN(b.low) && !isNaN(b.close);
            }});
            
            console.log(`Filtered to ${{finalData.length}} completely valid bricks (from ${{cleanRenkoData.length}})`);
            
            if (finalData.length > 0) {{
                try {{
                    console.log(`Setting ${{finalData.length}} Renko bricks immediately`);
                    console.log('First brick:', JSON.parse(JSON.stringify(finalData[0])));
                    console.log('Last brick:', JSON.parse(JSON.stringify(finalData[finalData.length - 1])));
                    
                    // Create a completely new array with fresh objects to avoid any reference issues
                    // Also sort by time and remove duplicates (LightweightCharts requires sorted, unique times)
                    const freshData = finalData
                        .map(b => ({{
                            time: Number(b.time),
                            open: Number(b.open),
                            high: Number(b.high),
                            low: Number(b.low),
                            close: Number(b.close)
                        }}))
                        .sort((a, b) => a.time - b.time) // Sort by time ascending
                        .filter((b, idx, arr) => {{
                            // Remove duplicates - keep first occurrence of each time
                            return idx === 0 || arr[idx - 1].time !== b.time;
                        }});
                    
                    console.log(`After sorting/dedup: ${{freshData.length}} bricks`);
                    console.log('Time range:', freshData[0].time, 'to', freshData[freshData.length - 1].time);
                    
                    // Final check - ensure no nulls/undefined
                    const hasNull = freshData.some(b => 
                        b.time == null || b.open == null || b.high == null || 
                        b.low == null || b.close == null ||
                        isNaN(b.time) || isNaN(b.open) || isNaN(b.high) || 
                        isNaN(b.low) || isNaN(b.close)
                    );
                    
                    if (hasNull) {{
                        console.error('ERROR: Found null/NaN in freshData after all processing!');
                        return;
                    }}
                    
                    // Set data with comprehensive error handling
                    // Wrap in try-catch to prevent errors from breaking the chart
                    try {{
                        // Log sample for debugging
                        console.log('Sample brick structure:', {{
                            time: typeof freshData[0].time,
                            open: typeof freshData[0].open,
                            high: typeof freshData[0].high,
                            low: typeof freshData[0].low,
                            close: typeof freshData[0].close
                        }});
                        
                        renkoSeries.setData(freshData);
                        chart.timeScale().fitContent();
                        
                        console.log('[OK] Renko data set successfully - ' + freshData.length + ' bricks');
                    }} catch (setErr) {{
                        // If setData fails, try creating a new series and setting data again
                        console.error('setData failed, attempting recovery:', setErr);
                        try {{
                            // Remove the old series and create a new one
                            chart.removeSeries(renkoSeries);
                            const newSeries = chart.addCandlestickSeries({{
                                upColor: '#26A69A',
                                downColor: '#EF5350',
                                borderDownColor: '#EF5350',
                                borderUpColor: '#26A69A',
                                wickDownColor: '#EF5350',
                                wickUpColor: '#26A69A',
                                priceLineVisible: true,
                                lastValueVisible: true,
                                priceLineWidth: 2,
                                title: 'Renko Bricks',
                                visible: true
                            }});
                            newSeries.setData(freshData);
                            chart.timeScale().fitContent();
                            console.log('[OK] Recovery successful - data set with new series');
                        }} catch (recoveryErr) {{
                            console.error('Recovery also failed:', recoveryErr);
                        }}
                    }}
                }} catch (err) {{
                    console.error('Error setting Renko data:', err);
                    console.error('Error stack:', err.stack);
                }}
            }} else {{
                console.error('No valid Renko data after final filter!');
            }}
        }} else {{
            console.error('No Renko data to set!');
        }}
        
        // OLD CODE - kept for reference but disabled (commented out to avoid syntax errors)
        // Disabled code removed - kept setData() simple like reference implementations
        /*
        DISABLED - removed complex delayed setData logic
        function setRenkoData() {{
            try {{
                // Create a final verification pass - ensure array is contiguous with no gaps
                const verifiedData = [];
                for (let i = 0; i < cleanRenkoData.length; i++) {{
                    const brick = finalRenkoData[i];
                    // Double-check every single value and ensure no null/undefined properties
                    if (brick && 
                        typeof brick === 'object' &&
                        brick !== null &&
                        brick !== undefined &&
                        typeof brick.time === 'number' && isFinite(brick.time) && brick.time > 0 &&
                        typeof brick.open === 'number' && isFinite(brick.open) &&
                        typeof brick.high === 'number' && isFinite(brick.high) &&
                        typeof brick.low === 'number' && isFinite(brick.low) &&
                        typeof brick.close === 'number' && isFinite(brick.close) &&
                        !isNaN(brick.time) && !isNaN(brick.open) && 
                        !isNaN(brick.high) && !isNaN(brick.low) && !isNaN(brick.close) &&
                        brick.time !== null && brick.open !== null &&
                        brick.high !== null && brick.low !== null && brick.close !== null &&
                        brick.time !== undefined && brick.open !== undefined &&
                        brick.high !== undefined && brick.low !== undefined && brick.close !== undefined) {{
                        // Create completely fresh object with ONLY the 5 required properties
                        // This ensures no extra properties or references exist
                        const cleanBrick = {{
                            time: Math.floor(Number(brick.time)),
                            open: Number(brick.open),
                            high: Number(brick.high),
                            low: Number(brick.low),
                            close: Number(brick.close)
                        }};
                        
                        // Final sanity check - ensure no nulls in the clean object
                        if (cleanBrick.time > 0 && 
                            isFinite(cleanBrick.open) && isFinite(cleanBrick.high) &&
                            isFinite(cleanBrick.low) && isFinite(cleanBrick.close) &&
                            !isNaN(cleanBrick.open) && !isNaN(cleanBrick.high) &&
                            !isNaN(cleanBrick.low) && !isNaN(cleanBrick.close)) {{
                            verifiedData.push(cleanBrick);
                        }} else {{
                            console.error(`Clean brick validation failed at index ${{i}}:`, cleanBrick);
                        }}
                    }} else {{
                        console.error(`Invalid brick at index ${{i}} failed verification:`, brick);
                    }}
                }}
                
                if (verifiedData.length === 0) {{
                    throw new Error('No valid data after final verification');
                }}
                
                // One more pass - ensure array has no gaps and all elements are valid
                const finalCleanData = verifiedData.filter(b => {{
                    return b && 
                           typeof b.time === 'number' && b.time > 0 &&
                           typeof b.open === 'number' && typeof b.high === 'number' &&
                           typeof b.low === 'number' && typeof b.close === 'number' &&
                           isFinite(b.time) && isFinite(b.open) && isFinite(b.high) &&
                           isFinite(b.low) && isFinite(b.close);
                }});
                
                console.log(`Setting ${{finalCleanData.length}} verified Renko bricks (from ${{verifiedData.length}} after cleaning)`);
                
                // Set data with error handling
                if (finalCleanData.length > 0) {{
                    const minPrice = Math.min(...finalCleanData.map(b => b.low));
                    const maxPrice = Math.max(...finalCleanData.map(b => b.high));
                    const firstTime = finalCleanData[0].time;
                    const lastTime = finalCleanData[finalCleanData.length - 1].time;
                    
                    console.log(`Setting Renko data: ${{finalCleanData.length}} bricks`);
                    console.log(`Time range: ${{new Date(firstTime * 1000).toLocaleString()}} to ${{new Date(lastTime * 1000).toLocaleString()}}`);
                    console.log(`Price range: ${{minPrice}} - ${{maxPrice}}`);
                    console.log(`First brick:`, finalCleanData[0]);
                    console.log(`Last brick:`, finalCleanData[finalCleanData.length - 1]);
                    
                    // Try setting data - catch and log any errors but continue
                    try {{
                        console.log('About to call setData with ${{finalCleanData.length}} bricks');
                        console.log('Sample brick (first):', JSON.stringify(finalCleanData[0]));
                        console.log('Sample brick (last):', JSON.stringify(finalCleanData[finalCleanData.length - 1]));
                        
                        renkoSeries.setData(finalCleanData);
                        console.log('✅ Renko data set successfully - ${{finalCleanData.length}} bricks');
                        
                        // Verify series options (data() method doesn't exist in this version)
                        try {{
                            // Check if series is visible
                            const seriesOptions = renkoSeries.options();
                            console.log('Series options:', seriesOptions);
                            console.log('Series visible:', seriesOptions.visible !== false);
                            console.log('Series type:', seriesOptions);
                        }} catch (dataErr) {{
                            console.warn('Could not get series options:', dataErr);
                        }}
                        
                        console.log(`Data array has ${{finalCleanData.length}} bricks`);
                        
                    }} catch (setDataErr) {{
                        console.error('❌ setData() threw error:', setDataErr);
                        console.error('Error details:', setDataErr.message);
                        if (setDataErr.stack) {{
                            console.error('Stack:', setDataErr.stack);
                        }}
                        // Still try to continue with price scale setup
                    }}
                    
                    // Set price scale to show data range with padding
                    try {{
                        const pricePadding = (maxPrice - minPrice) * 0.1; // 10% padding
                        renkoSeries.priceScale().applyOptions({{
                            autoScale: true,
                            scaleMargins: {{
                                top: 0.1,
                                bottom: 0.1
                            }}
                        }});
                        
                        // Make sure series is visible FIRST
                        renkoSeries.applyOptions({{
                            visible: true
                        }});
                        
                        console.log('Series visibility set to true');
                        
                        // Force chart to fit content first (this auto-scales)
                        chart.timeScale().fitContent();
                        console.log('Called fitContent() on time scale');
                        
                        // Set price scale explicitly with the data range
                        const pricePadding = (maxPrice - minPrice) * 0.05; // 5% padding
                        renkoSeries.priceScale().applyOptions({{
                            autoScale: true,
                            scaleMargins: {{
                                top: 0.05,
                                bottom: 0.05
                            }}
                        }});
                        
                        // Try setting explicit price range as backup
                        setTimeout(() => {{
                            try {{
                                renkoSeries.priceScale().setVisibleRange({{
                                    from: minPrice - pricePadding,
                                    to: maxPrice + pricePadding
                                }});
                                console.log(`Set explicit price range: ${{minPrice - pricePadding}} to ${{maxPrice + pricePadding}}`);
                            }} catch (rangeErr) {{
                                console.log('setVisibleRange not available, using autoScale only');
                            }}
                        }}, 100);
                        
                        console.log('Set price scale to autoScale: true');
                        
                        console.log('Set explicit time range and made series visible');
                        console.log(`Time range set: ${{firstTime}} (${{new Date(firstTime * 1000).toLocaleString()}}) to ${{lastTime}} (${{new Date(lastTime * 1000).toLocaleString()}})`);
                        console.log(`Price range: ${{minPrice}} to ${{maxPrice}}`);
                        
                        // Ensure everything is visible after a brief delay
                        setTimeout(() => {{
                            // Verify and log current state
                            const visibleRange = chart.timeScale().getVisibleRange();
                            console.log('=== CHART STATE CHECK ===');
                            if (visibleRange) {{
                                console.log(`Visible time range: ${{visibleRange.from}} ({{new Date(visibleRange.from * 1000).toLocaleString()}}) to ${{visibleRange.to}} ({{new Date(visibleRange.to * 1000).toLocaleString()}})`);
                                console.log(`Data time range: ${{firstTime}} ({{new Date(firstTime * 1000).toLocaleString()}}) to ${{lastTime}} ({{new Date(lastTime * 1000).toLocaleString()}})`);
                            }} else {{
                                console.warn('⚠️ Visible range is null - forcing setVisibleRange');
                                chart.timeScale().setVisibleRange({{
                                    from: firstTime,
                                    to: lastTime
                                }}, true);
                            }}
                            
                            // Verify data array (series.data() doesn't exist in this LightweightCharts version)
                            console.log(`Final data array has ${{finalCleanData.length}} bricks`);
                            if (finalCleanData.length > 0) {{
                                const dataMin = Math.min(...finalCleanData.map(d => d.low));
                                const dataMax = Math.max(...finalCleanData.map(d => d.high));
                                console.log(`Data price range: ${{dataMin}} to ${{dataMax}}`);
                            }}
                            
                            // Force fit content again
                            chart.timeScale().fitContent();
                            
                            // Ensure auto-scale is enabled
                            renkoSeries.priceScale().applyOptions({{
                                autoScale: true,
                                scaleMargins: {{
                                    top: 0.05,
                                    bottom: 0.05
                                }}
                            }});
                            
                            // Verify series is visible
                            const opts = renkoSeries.options();
                            console.log(`Series visible: ${{opts.visible}}, Series type: ${{opts.type || 'candlestick'}}`);
                            
                            // Force a resize/redraw by temporarily resizing the chart
                            const currentWidth = chartContainer.clientWidth;
                            chart.applyOptions({{ width: currentWidth - 1 }});
                            setTimeout(() => {{
                                chart.applyOptions({{ width: currentWidth }});
                                chart.timeScale().fitContent();
                                console.log('Forced chart resize/redraw');
                                
                                // Test: Try adding a simple line to verify chart rendering works
                                try {{
                                    const testLine = chart.addLineSeries({{
                                        color: '#FFFF00',
                                        lineWidth: 3,
                                        title: 'Test Line'
                                    }});
                                    // Add a test point at the middle of our data range
                                    const midTime = Math.floor((firstTime + lastTime) / 2);
                                    const midPrice = (minPrice + maxPrice) / 2;
                                    testLine.setData([{{
                                        time: midTime,
                                        value: midPrice
                                    }}, {{
                                        time: lastTime,
                                        value: midPrice + 10
                                    }}]);
                                    console.log(`Added test line at time ${{midTime}}, price ${{midPrice}}`);
                                    console.log('If you see a yellow line, chart rendering works - issue is with candlesticks');
                                }} catch (testErr) {{
                                    console.error('Could not add test line:', testErr);
                                }}
                            }}, 50);
                            
                            console.log('=== END STATE CHECK ===');
                        }}, 500);
                        
                        // Also try a longer delay in case the chart needs more time
                        setTimeout(() => {{
                            chart.timeScale().fitContent();
                            console.log('Final fitContent() call after 1 second');
                        }}, 1000);
                    }} catch (scaleErr) {{
                        console.error('Error setting price scale:', scaleErr);
                    }}
                }} else {{
                    console.error('No data to set!');
                }}
            }} catch (error) {{
                // Only log if it's not the known internal error
                if (!error.message || !error.message.includes('Value is null')) {{
                    console.error('❌ Error setting Renko data:', error);
                    document.getElementById('chart-container').innerHTML = 
                        '<div style="color: #EF5350; padding: 20px;">Error: Failed to set chart data. Check console for details.</div>';
                }}
            }}
        }}
        
        */
        // END OF DISABLED CODE

        // Filter and validate Supertrend data with same strict checks
        const validSupertrendData = data.supertrend.map(point => {{
            return {{
                time: Number(point.time),
                value: Number(point.value),
                direction: Number(point.direction)
            }};
        }}).filter(point => {{
            return typeof point.time === 'number' && isFinite(point.time) && point.time > 0 &&
                   typeof point.value === 'number' && isFinite(point.value) &&
                   typeof point.direction === 'number' && isFinite(point.direction);
        }});
        
        // Add Supertrend overlay AFTER Renko data is set (with additional delay)
        // This ensures the chart has fully processed the Renko data before adding more series
        // Use multiple requestAnimationFrame calls to ensure the chart is fully rendered
        requestAnimationFrame(() => {{
            requestAnimationFrame(() => {{
                requestAnimationFrame(() => {{
                    if (validSupertrendData.length > 0) {{
                                    console.log(`Plotting ${{validSupertrendData.length}} Supertrend points`);
                        const supertrendSegments = [];
                        let currentDirection = null;
                        let currentSegment = [];
                        
                        validSupertrendData.forEach((point, index) => {{
                            // Ensure point has valid time and value before processing
                            if (typeof point.time !== 'number' || !isFinite(point.time) || point.time <= 0 ||
                                typeof point.value !== 'number' || !isFinite(point.value)) {{
                                console.warn(`Skipping invalid Supertrend point at index ${{index}}:`, point);
                                return;
                            }}
                            
                            // Create clean point with only time and value (no direction in data array)
                            const cleanPoint = {{
                                time: Number(point.time),
                                value: Number(point.value)
                            }};
                            
                            // Validate clean point
                            if (!isFinite(cleanPoint.time) || cleanPoint.time <= 0 ||
                                !isFinite(cleanPoint.value) || cleanPoint.value === null) {{
                                console.warn(`Skipping invalid point in segment creation:`, point);
                                return;
                            }}
                            
                            if (currentDirection === null) {{
                                currentDirection = Number(point.direction);
                                currentSegment = [cleanPoint];
                            }} else if (currentDirection === Number(point.direction)) {{
                                currentSegment.push(cleanPoint);
                            }} else {{
                                // Direction changed, finalize current segment
                                if (currentSegment.length > 0) {{
                                    supertrendSegments.push({{
                                        data: currentSegment.slice(), // Copy array
                                        color: currentDirection === 1 ? '#26A69A' : '#EF5350',
                                        direction: currentDirection
                                    }});
                                }}
                                currentDirection = Number(point.direction);
                                currentSegment = [cleanPoint];
                            }}
                        }});
                        
                        // Add the last segment (already cleaned during creation)
                        if (currentSegment.length > 0) {{
                            supertrendSegments.push({{
                                data: currentSegment.slice(), // Copy array
                                color: currentDirection === 1 ? '#26A69A' : '#EF5350',
                                direction: currentDirection
                            }});
                        }}
                        
                        console.log(`Created ${{supertrendSegments.length}} Supertrend segments from ${{validSupertrendData.length}} points`);
                        
                        // Create line series for each segment
                        supertrendSegments.forEach((segment, index) => {{
                            console.log(`Processing segment ${{index}} with ${{segment.data.length}} points`);
                            // Create completely fresh array with only valid number properties
                            // This ensures no null values can exist in the data
                            const validSegmentData = [];
                            
                            for (let i = 0; i < segment.data.length; i++) {{
                                const p = segment.data[i];
                                
                                // Skip null/undefined
                                if (!p || p === null || p === undefined) {{
                                    continue;
                                }}
                                
                                // Extract and validate time
                                let time = null;
                                if (typeof p.time === 'number') {{
                                    time = p.time;
                                }} else if (p.time != null) {{
                                    time = Number(p.time);
                                }}
                                
                                // Extract and validate value
                                let value = null;
                                if (typeof p.value === 'number') {{
                                    value = p.value;
                                }} else if (p.value != null) {{
                                    value = Number(p.value);
                                }}
                                
                                // Only add if both are valid finite numbers
                                // Note: value can be any finite number (positive, negative, or zero)
                                if (time != null && value != null &&
                                    typeof time === 'number' && typeof value === 'number' &&
                                    isFinite(time) && isFinite(value) &&
                                    time > 0) {{
                                    // Create new object to avoid any reference issues
                                    validSegmentData.push({{
                                        time: time,
                                        value: value
                                    }});
                                }}
                            }}
                            
                            if (validSegmentData.length === 0) {{
                                console.warn(`Skipping empty Supertrend segment ${{index}} (had ${{segment.data.length}} points but none valid)`);
                                return;
                            }}
                            
                            // Final validation pass: check every single value
                            const finalSegmentData = [];
                            for (const p of validSegmentData) {{
                                if (p && 
                                    p.time !== null && p.time !== undefined && typeof p.time === 'number' && isFinite(p.time) &&
                                    p.value !== null && p.value !== undefined && typeof p.value === 'number' && isFinite(p.value)) {{
                                    finalSegmentData.push({{time: p.time, value: p.value}});
                                }}
                            }}
                            
                            if (finalSegmentData.length === 0) {{
                                console.warn(`Supertrend segment ${{index}} failed final validation (had ${{validSegmentData.length}} but none passed)`);
                                return;
                            }}
                            
                            // Line series needs at least 2 points
                            if (finalSegmentData.length < 2) {{
                                console.warn(`Skipping Supertrend segment ${{index}} - only ${{finalSegmentData.length}} point(s) (line series needs at least 2)`);
                                return;
                            }}
                            
                            // Verify every single point one more time before passing to chart
                            const chartData = [];
                            for (const p of finalSegmentData) {{
                                const t = p.time;
                                const v = p.value;
                                
                                // Absolute strict validation
                                if (t !== null && t !== undefined && 
                                    v !== null && v !== undefined &&
                                    typeof t === 'number' && typeof v === 'number' &&
                                    isFinite(t) && isFinite(v) &&
                                    !isNaN(t) && !isNaN(v)) {{
                                    chartData.push({{time: t, value: v}});
                                }}
                            }}
                            
                            if (chartData.length < 2) {{
                                console.warn(`Supertrend segment ${{index}} has insufficient valid points after final check (${{chartData.length}} < 2)`);
                                return;
                            }}
                            
                            try {{
                                const segmentSeries = chart.addLineSeries({{
                                    color: segment.color,
                                    lineWidth: 2,
                                    title: '',
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                    priceLineWidth: 0
                                }});
                                
                                segmentSeries.setData(chartData);
                                console.log(`✅ Supertrend segment ${{index}} set with ${{chartData.length}} points`);
                            }} catch (error) {{
                                console.error(`❌ Error setting Supertrend segment ${{index}}:`, error);
                                console.error('Segment had', finalSegmentData.length, 'points before final check');
                                console.error('First point:', chartData[0]);
                                console.error('Last point:', chartData[chartData.length - 1]);
                                if (chartData.length > 0) {{
                                    // Check each point for null
                                    chartData.forEach((p, idx) => {{
                                        if (p == null || p.time == null || p.value == null) {{
                                            console.error(`Null found at index ${{idx}}:`, p);
                                        }}
                                    }});
                                }}
                            }}
                        }});
                    }}
                }});
            }});
        }});

        // Helper function to set text
        function setText(id, text) {{
            const element = document.getElementById(id);
            if (element) element.textContent = text;
        }}

        // Format time
        function formatTime(time) {{
            const date = new Date(time * 1000);
            return date.toLocaleString('en-IN', {{ 
                timeZone: 'Asia/Kolkata',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            }});
        }}

        // Live crosshair updates with extensive error handling
        chart.subscribeCrosshairMove(param => {{
            try {{
                if (!param || param === null || param === undefined) return;
                if (!param.point || param.point === null || param.point === undefined) return;
                
                let sd = null;
                try {{
                    if (param.seriesData && typeof param.seriesData.get === 'function') {{
                        sd = param.seriesData.get(renkoSeries);
                    }}
                }} catch (e) {{
                    // Silently ignore errors accessing seriesData
                    sd = null;
                }}
                
                let p = sd;
                if (!p || p === null || p === undefined) {{
                    try {{
                        if (param.seriesPrices && typeof param.seriesPrices.get === 'function') {{
                            p = param.seriesPrices.get(renkoSeries);
                        }}
                    }} catch (e) {{
                        // Silently ignore errors accessing seriesPrices
                        p = null;
                    }}
                }}
                
                if (!p || p === null || p === undefined) return;
                
                // Safely extract display time (for chart coordinate lookup)
                let displayTime = null;
                if (param.time != null && typeof param.time === 'number' && isFinite(param.time)) {{
                    displayTime = param.time;
                }} else if (p && p.time != null && typeof p.time === 'number' && isFinite(p.time)) {{
                    displayTime = p.time;
                }}
                
                if (displayTime === null || !isFinite(displayTime)) return;
                
                // Look up actual timestamp from CSV (for tooltip display)
                // Try exact match first, then find closest match
                let actualTime = displayTime;
                
                // First try exact map lookup
                if (timeLookupMap.has(displayTime)) {{
                    actualTime = timeLookupMap.get(displayTime);
                }} else {{
                    // Find closest display_time match in array (for interpolated times between bricks)
                    let closestBrick = null;
                    let minDiff = Infinity;
                    for (const brick of rawRenkoWithActualTime) {{
                        const diff = Math.abs(brick.displayTime - displayTime);
                        if (diff < minDiff) {{
                            minDiff = diff;
                            closestBrick = brick;
                        }}
                    }}
                    // Use closest match if within 60 seconds
                    if (closestBrick !== null && minDiff <= 60) {{
                        actualTime = closestBrick.actualTime;
                    }}
                }}

                // Validate OHLC values before displaying with null checks
                let open = '-';
                let high = '-';
                let low = '-';
                let close = '-';
                
                if (p.open != null && typeof p.open === 'number' && isFinite(p.open) && !isNaN(p.open)) {{
                    open = Number(p.open).toFixed(2);
                }}
                if (p.high != null && typeof p.high === 'number' && isFinite(p.high) && !isNaN(p.high)) {{
                    high = Number(p.high).toFixed(2);
                }}
                if (p.low != null && typeof p.low === 'number' && isFinite(p.low) && !isNaN(p.low)) {{
                    low = Number(p.low).toFixed(2);
                }}
                if (p.close != null && typeof p.close === 'number' && isFinite(p.close) && !isNaN(p.close)) {{
                    close = Number(p.close).toFixed(2);
                }}

                try {{
                    // Display actual timestamp from CSV in tooltip
                    setText('md-time', formatTime(actualTime));
                    setText('md-open', open);
                    setText('md-high', high);
                    setText('md-low', low);
                    setText('md-close', close);
                }} catch (e) {{
                    // Ignore errors setting text
                }}

                // Find matching Supertrend value - use displayTime for matching (supertrend uses display_time)
                let match = null;
                if (validSupertrendData && Array.isArray(validSupertrendData) && validSupertrendData.length > 0) {{
                    try {{
                        match = validSupertrendData.find(b => {{
                            if (!b || b === null || b === undefined) return false;
                            if (typeof b.time !== 'number' || !isFinite(b.time)) return false;
                            return b.time === displayTime;
                        }}) || null;
                        
                        if (!match) {{
                            let minDiff = Infinity;
                            for (const b of validSupertrendData) {{
                                if (!b || b === null || b === undefined) continue;
                                if (typeof b.time !== 'number' || !isFinite(b.time)) continue;
                                const d = Math.abs(b.time - displayTime);
                                if (d < minDiff) {{ minDiff = d; match = b; }}
                            }}
                            // Only use match if within 60 seconds
                            if (minDiff > 60) match = null;
                        }}
                    }} catch (e) {{
                        // Ignore errors finding match
                        match = null;
                    }}
                }}
                
                // Validate match before using
                try {{
                    if (match && match !== null && match !== undefined &&
                        match.value != null && typeof match.value === 'number' && 
                        isFinite(match.value) && !isNaN(match.value)) {{
                        setText('md-st', Number(match.value).toFixed(2));
                        setText('md-st-dir', (match.direction === 1 ? 'Bullish' : 'Bearish'));
                    }} else {{
                        setText('md-st', '-');
                        setText('md-st-dir', '-');
                    }}
                }} catch (e) {{
                    // Ignore errors setting ST text
                }}
            }} catch (error) {{
                // Completely ignore all errors in crosshair callback to prevent breaking the chart
                // console.error('Crosshair error (ignored):', error);
            }}
        }});

        // Initial display - use last brick from data with actual timestamp lookup
        try {{
            if (data.renko && data.renko.length > 0) {{
                const lastBrick = data.renko[data.renko.length - 1];
                if (lastBrick && lastBrick !== null && lastBrick !== undefined) {{
                    // Look up actual timestamp from CSV for display
                    const displayTime = lastBrick.time;
                    let actualTime = displayTime;
                    if (timeLookupMap.has(displayTime)) {{
                        actualTime = timeLookupMap.get(displayTime);
                    }}
                    
                    if (actualTime != null && typeof actualTime === 'number' && isFinite(actualTime)) {{
                        try {{
                            setText('md-time', formatTime(actualTime));
                        }} catch (e) {{}}
                    }}
                    if (lastBrick.open != null && typeof lastBrick.open === 'number' && isFinite(lastBrick.open)) {{
                        try {{
                            setText('md-open', Number(lastBrick.open).toFixed(2));
                        }} catch (e) {{}}
                    }}
                    if (lastBrick.high != null && typeof lastBrick.high === 'number' && isFinite(lastBrick.high)) {{
                        try {{
                            setText('md-high', Number(lastBrick.high).toFixed(2));
                        }} catch (e) {{}}
                    }}
                    if (lastBrick.low != null && typeof lastBrick.low === 'number' && isFinite(lastBrick.low)) {{
                        try {{
                            setText('md-low', Number(lastBrick.low).toFixed(2));
                        }} catch (e) {{}}
                    }}
                    if (lastBrick.close != null && typeof lastBrick.close === 'number' && isFinite(lastBrick.close)) {{
                        try {{
                            setText('md-close', Number(lastBrick.close).toFixed(2));
                        }} catch (e) {{}}
                    }}
                }}
                
                if (validSupertrendData && Array.isArray(validSupertrendData) && validSupertrendData.length > 0) {{
                    const lastST = validSupertrendData[validSupertrendData.length - 1];
                    if (lastST && lastST !== null && lastST !== undefined &&
                        lastST.value != null && typeof lastST.value === 'number' && isFinite(lastST.value)) {{
                        try {{
                            setText('md-st', Number(lastST.value).toFixed(2));
                            setText('md-st-dir', lastST.direction === 1 ? 'Bullish' : 'Bearish');
                        }} catch (e) {{}}
                    }}
                }}
            }}
        }} catch (error) {{
            // Ignore all errors in initial display
        }}
    }});
    </script>
</body>
</html>'''
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    logger.info(f"✅ Renko chart HTML generated: {output_file}")
    return output_file

def main():
    """Main function"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Plot Renko bricks with Supertrend indicator')
    parser.add_argument('csv_file', type=str, nargs='?', 
                       default=None,
                       help='Input Renko CSV file (default: nifty50_1min_data_renko.csv in script directory)')
    parser.add_argument('--output', '-o', type=str, default=None, help='Output HTML file path')
    parser.add_argument('--config', '-c', type=str, default=None, help='Path to renko_config.yaml')
    
    args = parser.parse_args()
    
    # Default to nifty50_1min_data_renko.csv in script directory if not provided
    if args.csv_file is None:
        csv_path = Path(__file__).parent / 'nifty50_1min_data_renko.csv'
        logger.info(f"No CSV file specified, using default: {csv_path}")
    else:
        csv_path = Path(args.csv_file)
    
    if not csv_path.exists():
        logger.error(f"CSV file not found: {csv_path}")
        logger.error(f"Expected file generated by convert_renko.py using stocktrends library")
        sys.exit(1)
    
    output_path = Path(args.output) if args.output else Path(__file__).parent / 'nifty_renko_plot.html'
    config_path = Path(args.config) if args.config else None
    
    logger.info(f"Generating Renko chart from {csv_path}")
    generate_html(csv_path, output_path, config_path)
    logger.info(f"✅ Chart generated successfully: {output_path}")

if __name__ == "__main__":
    main()

